[weisse]
states = 
	Si  = [0],
	P   = [1000.0],
	R   = [10.0],
	M   = [0],
	T   = [0],
	Q   = [0],
	H   = [0],
	rmr = [0],
	rmh = [0],
	rmq = [0],
	rmt = [0],
	rmm = [0],
	zmm = [0],
	zmr = [0],
	zmh = [0],
	zmq = [0],
	zmt = [0],
	mr  = [0],
	mm  = [0],
	mt  = [0],
	mq  = [0],
	mh  = [0]
	
params =
	n_cell   = [1.0e8],
	vt       = [726.0],
	kt       = [1.0e3],
	ys       = [0.5],
	vs       = [5800.0],
	ks       = [1.0e3],
	vprot    = [1260.0],
	kprot    = [180.1378030928276],
	nr       = [7549.0],
	nm       = [300.0],
	bind_R   = [1],
	unbind_R = [1.0],
	bind_Z   = [0.005990373118888],
	unbind_Z = [0],
	degm     = [0.1],
	wr       = [929.9678874564831],
	wm       = [4.139172187824451],
	wq       = [948.9349882947897],
	wp       = [0.0],
	kr       = [426.8693338968694],
	kx       = [4.379733394834643],
	iq       = [1.522190403737490e+05],
	nq       = [4]

inputs = 
	Se = [[1.0e4]],
	cl = [[0]]
	
equations = 
	
	kprot_  = vprot/kprot
	vprot_  = vprot*P/(kprot_ + P)
	synprot = (rmq + rmr + rmh + rmt + rmm)*vprot_
	mu      = synprot/n_cell
	synp    = M*vs*Si/(ks + Si)
	
	#Rate constants
	bind_R_       = bind_R*R
	bind_Z_       = cl*bind_Z
	q_feedback    = 1/(1 + (Q/iq)**nq)
	all_bind_R    = bind_R_*(mr + mm + mt + mq + mh)
	all_unbind_R  = unbind_R*(rmr + rmm + rmt + rmq + rmh)
	uptake        = T*vt*Se/(kt + Se)
	termination   = vprot_*(rmr/nr + rmt/nm +rmm/nm +rmq/nm +rmh/nm) 
	
	#Differentials
	drmr = bind_R_*mr+unbind_Z*zmr-unbind_R*rmr-vprot_/nr*rmr-bind_Z_*rmr-mu*rmr
	drmm = bind_R_*mm+unbind_Z*zmm-unbind_R*rmm-vprot_/nm*rmm-bind_Z_*rmm-mu*rmm
	drmq = bind_R_*mq+unbind_Z*zmq-unbind_R*rmq-vprot_/nm*rmq-bind_Z_*rmq-mu*rmq
	drmt = bind_R_*mt+unbind_Z*zmt-unbind_R*rmt-vprot_/nm*rmt-bind_Z_*rmt-mu*rmt
	drmh = bind_R_*mh+unbind_Z*zmh-unbind_R*rmh-vprot_/nm*rmh-bind_Z_*rmh-mu*rmh

	dzmm = -mu*zmm +bind_Z_*rmm -unbind_Z*zmm
	dzmr = -mu*zmr +bind_Z_*rmr -unbind_Z*zmr
	dzmh = -mu*zmh +bind_Z_*rmh -unbind_Z*zmh
	dzmq = -mu*zmq +bind_Z_*rmq -unbind_Z*zmq
	dzmt = -mu*zmt +bind_Z_*rmt -unbind_Z*zmt
	
	dmr  = -mu*mr  -degm*mr +unbind_R*rmr -bind_R_*mr +vprot_/nr*rmr +wr*P/(kr + P)
	dmm  = -mu*mm  -degm*mm +unbind_R*rmm -bind_R_*mm +vprot_/nm*rmm +wm*P/(kx + P)
	dmt  = -mu*mt  -degm*mt +unbind_R*rmt -bind_R_*mt +vprot_/nm*rmt +wm*P/(kx + P)
	dmq  = -mu*mq  -degm*mq +unbind_R*rmq -bind_R_*mq +vprot_/nm*rmq +wq*P/(kx + P)*q_feedback
	dmh  = -mu*mh  -degm*mh +unbind_R*rmh -bind_R_*mh +vprot_/nm*rmh +wp*P/(kx + P)
	
	dR   = -mu*R +vprot_/nr*rmr +all_unbind_R -all_bind_R +termination
	dM   = -mu*M +vprot_/nm*rmm
	dT   = -mu*T +vprot_/nm*rmt
	dQ   = -mu*Q +vprot_/nm*rmq
	dH   = -mu*H +vprot_/nm*rmh
	dSi  = -mu*Si +uptake -synp
	dP   = -mu*P + ys*synp -synprot
	
tspan = linspace(0, 1000, 11)	

solver_args = 
	method = 'Radau'

objective_R_frac =
	all_R    = R + rmr + rmh + rmt + rmm + rmq + zmr + zmh + zmt + zmm + zmq
	all_notR = H + Q + T + M
	R_frac   = nr*all_R / ( nr*all_R + nm*all_notR)
	
	return t, R_frac